/**
 * Generated by worldstate.js
 */
'use strict';

var ImmutableGraphObject = require('worldstate/src/Base/ImmutableGraphObject');
var ImmutableGraphRegistry =
    require('worldstate/src/Base/ImmutableGraphRegistry');
var GeneratorInstanceRegistry = require('worldstate/src/Base/GeneratorInstanceRegistry');



/**
 * A factory for {Item}
 *
 * @lends {Item}
 */
var ItemFactory = {
  /**
   * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} obj JSON input data
   * @param {{}} parent
   * @param {string} parentKey
   * @return {ItemPrototype}
   */
  newInstance: function Item$newInstance(obj, parent, parentKey) {

    /**
     * Item
     *
     * @constructor
     * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} obj JSON input data
     */
    var ItemClass = function ItemClass(obj, parent, parentKey) {
      this.__private = {
        graph: null,
        wrappers: {}
      };
      this.__private.graph = ImmutableGraphRegistry.getImmutableObject(obj, parent, parentKey);
    };
    ItemClass.prototype = ItemPrototype;
    var instance = new ItemClass(obj, parent, parentKey);
    GeneratorInstanceRegistry.registerInstance(obj, this);
    return instance;
  }
};


/**
 * @lends {ItemPrototype}
 */
var ItemPrototype = {
  /**
   * @private
   * @struct
   */
  __private: {
    graph: null,
    wrappers: {}
  },

    /**
   * Change reference
   *
   * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} obj
   * @this {ItemPrototype}
   * @return {ItemPrototype}
   */
  changeReferenceTo: function Item$changeReferenceTo(obj) {
    this.__private.graph.changeReferenceTo(obj);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Change value
   *
   * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} val
   * @this {ItemPrototype}
   * @return {ItemPrototype}
   */
  changeValueTo: function Item$changeValueTo(val) {
    this.__private.graph.changeValueTo(val);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Enable versioning
   *
   * @this {ItemPrototype}
   * @return {ItemPrototype}
   */
  enableVersioning: function Item$enableVersioning() {
    this.__private.graph.enableVersioning();
    return this;
  },

  /**
   * Get all the versions
   *
   * @return {[{name:string, ref:object}]}
   * @this {ItemPrototype}
   */
  getVersions: function Item$getVersions() {
    return this.__private.graph.getVersions();
  },

  /**
   * Get the actual immutable object
   *
   * @return {{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}}
   * @this {ItemPrototype}
   */
  read: function Item$read() {
    if (!this.__private.graph.__private.refToObj) {
      return null;
    }
    return this.__private.graph.__private.refToObj.ref;
  },

  /**
   * Restore a version
   *
   * @param {{name:string, ref:object}} version version to restore
   * @this {ItemPrototype}
   * @return {ItemPrototype}
   */
  restoreVersion: function Item$restoreVersion(version) {
    this.__private.graph.restoreVersion(version);
    return this;
  },

  /**
   * Save a version (versioning must be enabled).
   *
   * @param {string} name name of the version
   * @param {boolean} delayedExecution
   * @this {ItemPrototype}
   * @return {ItemPrototype}
   */
  saveVersionAs: function Item$saveVersionAs(name, delayedExecution) {
    this.__private.graph.saveVersion(name, delayedExecution);
    var self = this;
    return {
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Executes after the current actions, like insert and
   * changeValueTo, have completed
   *
   * @param {function} fn
   * @param {boolean} once
   * @this {ItemPrototype}
   */
  afterChange: function Item$afterChange(fn, once) {
    this.__private.graph.afterChange(fn, once);
  },

  /**
   * Remove this part of the graph
   *
   * @this {ItemPrototype}
   * @return {ItemPrototype}
   */
  remove: function Item$remove() {
    this.__private.graph.remove();
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Get the WorldState.js generated id
   *
   * @return {number}
   */
  generatedId: function Item$generatedId() {
    return this.__private.graph.generatedId();
  },

  /**
   * Change one or more properties at once
   *
   * @param {{}} newProperties
   * @return {ItemPrototype}
   */
  changePropertiesTo: function Item$changePropertiesTo(newProperties) {
    this.__private.graph.changePropertiesTo(newProperties);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Add a change listener
   *
   * @param {function} fn
   * @param {{}} context
   * @return {ItemPrototype}
   */
  addChangeListener: function Item$addChangeListener(fn, context) {
    this.__private.graph.addChangeListener(fn, context);
    return this;
  },

  /**
   * Add an edge to another object
   *
   * @return {ItemPrototype}
   */
  addEdgeTo: function(topic, imo) {
    this.__private.graph.addEdgeTo(topic, imo.__private.graph);
    return this;
  },

  /**
   * Remove edge to another object
   *
   * @return {ItemPrototype}
   */
  removeEdgeTo: function(topic, imo) {
    this.__private.graph.removeEdgeTo(topic, imo.__private.graph);
    return this;
  },

  /**
   * Get edges coming from other objects
   *
   * @return {ItemPrototype}
   */
  getIncomingEdges: function() {
    var realEdges = this.__private.graph.getIncomingEdges();
    var edges = [];
    for (var i = 0, l = realEdges.length; i < l; i++){
      var realEdge = realEdges[i];
      edges[i] = {
        origin: GeneratorInstanceRegistry.getInstance(realEdge.origin),
        destination: Item.newInstance(realEdge.destination.__private.refToObj.ref),
        type: realEdge.type,
        details: realEdge.details
      };
    }

    return edges;
  },

  /**
   * Get edges going to other objects
   *
   * @return {ItemPrototype}
   */
  getOutgoingEdges: function() {
    var realEdges = this.__private.graph.getOutgoingEdges();
    var edges = [];
    for (var i = 0, l = realEdges.length; i < l; i++){
      var realEdge = realEdges[i];
      edges[i] = {
        destination: GeneratorInstanceRegistry.getInstance(realEdge.destination),
        origin: Item.newInstance(realEdge.origin.__private.refToObj.ref),
        type: realEdge.type,
        details: realEdge.details
      };
    }
    return edges;
  }

};

module.exports = ItemFactory;
