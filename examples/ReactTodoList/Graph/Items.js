/**
 * Generated by worldstate.js.
 */
'use strict';

var ImmutableGraphObject = require('worldstate/src/Base/ImmutableGraphObject');
var ImmutableGraphRegistry =
    require('worldstate/src/Base/ImmutableGraphRegistry');

/* @type Item */
var Item = require('./Item');


/**
 * A factory for {Items}
 *
 * @lends {Items}
 */
var ItemsFactory = {
  /**
   * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} obj JSON input data
   * @return {ItemsPrototype}
   */
  newInstance: function Items$newInstance(obj, parent, parentKey) {

    /**
     * Items
     *
     * @constructor
     * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} obj JSON input data
     */
    var ItemsClass = function ItemsClass(obj, parent, parentKey) {
      this.__private = {
        graph: null,
        wrappers: {}
      };
      this.__private.graph = ImmutableGraphRegistry.getImmutableObject(obj, parent, parentKey);
    };
    ItemsClass.prototype = ItemsPrototype;

    var instance = new ItemsClass(obj, parent, parentKey);
    return instance;
  }
};


/**
 * @lends {ItemsPrototype}
 */
var ItemsPrototype = {
  /**
   * @private
   * @struct
   */
  __private: {
    graph: null,
    wrappers: {}
  },

    /**
   * Change reference
   *
   * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} obj
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  changeReferenceTo: function Items$changeReferenceTo(obj) {
    this.__private.graph.changeReferenceTo(obj);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Change value
   *
   * @param {[{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}]} val
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  changeValueTo: function Items$changeValueTo(val) {
    this.__private.graph.changeValueTo(val);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Enable versioning
   *
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  enableVersioning: function Items$enableVersioning() {
    this.__private.graph.enableVersioning();
    return this;
  },

  /**
   * Get all the versions
   *
   * @return {[{name:string, ref:object}]}
   * @this {ItemsPrototype}
   */
  getVersions: function Items$getVersions() {
    return this.__private.graph.getVersions();
  },

  /**
   * Get the actual immutable object
   *
   * @return {{id:number,text:string,isComplete:boolean,editMode:boolean,test1:object,test2:object}}
   * @this {ItemsPrototype}
   */
  read: function Items$read() {
    if (!this.__private.graph.__private.refToObj) {
      return null;
    }
    return this.__private.graph.__private.refToObj.ref;
  },

  /**
   * Restore a version
   *
   * @param {{name:string, ref:object}} version version to restore
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  restoreVersion: function Items$restoreVersion(version) {
    this.__private.graph.restoreVersion(version);
    return this;
  },

  /**
   * Save a version (versioning must be enabled).
   *
   * @param {string} name name of the version
   * @param {boolean} delayedExecution
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  saveVersionAs: function Items$saveVersionAs(name, delayedExecution) {
    this.__private.graph.saveVersion(name, delayedExecution);
    var self = this;
    return {
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Executes after the current actions, like insert and
   * changeValueTo, have completed
   *
   * @param {function} fn
   * @param {boolean} once
   * @this {ItemsPrototype}
   */
  afterChange: function Items$afterChange(fn, once) {
    this.__private.graph.afterChange(fn, once);
  },

  /**
   * Remove this part of the graph
   *
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  remove: function Items$remove() {
    this.__private.graph.remove();
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Get the WorldState.js generated id
   *
   * @return {number}
   */
  generatedId: function Items$generatedId() {
    return this.__private.graph.generatedId();
  },

  /**
   * Add a change listener
   *
   * @param {function} fn
   * @param {{}} context
   * @return {ItemsPrototype}
   */
  addChangeListener: function Items$addChangeListener(fn, context) {
    this.__private.graph.addChangeListener(fn, context);
    return this;
  },

  /**
   * Get item at given position
   *
   * @param {number} position
   * @return {ItemPrototype}
   * @this {ItemsPrototype}
   */
  at: function Items$at(position) {
    var item = this.__private.graph.at(position);
    var instance = Item.newInstance(item.__private.refToObj.ref, this.__private.graph, position);
    return instance;
  },

  /**
   * Insert item
   *
   * @param {ItemPrototype} item
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  insert: function Items$insert(item) {
    var realItem = item.__private.graph.__private.refToObj.ref;
    this.__private.graph.insert(realItem);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Insert an item at the given position
   *
   * @param {number} position
   * @param {ItemPrototype} item
   * @return {ItemsPrototype}
   */
  insertAt: function Items$insertAt(position, item) {
    this.__private.graph.insertAt(position, item.__private.graph.read());
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Insert multiple items. Items with the same id property get replaced
   * with the new version.
   *
   * @param {[ItemPrototype]} items
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  insertMulti: function Items$insertMulti(items) {
    var realItems = [];
    for (var i = 0, l = items.length; i < l; i++) {
      realItems[i] = items[i].__private.graph.__private.refToObj.ref;
    }
    this.insertMultiRaw(realItems);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Insert multiple items. Items with the same id property get replaced
   * with the new version.
   *
   * @param {[ItemPrototype]} items
   * @this {ItemsPrototype}
   * @return {ItemsPrototype}
   */
  insertMultiRaw: function Items$insertMultiRaw(items) {
    this.__private.graph.insertMulti(items);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Get items that have the given conditions
   *
   * @param {Object.<*, *>} conditions
   * @param {boolean} cached
   * @return {[ItemPrototype]}
   * @this {ItemsPrototype}
   */
  where: function Items$where(conditions, cached) {
    var realItems = this.__private.graph.where(conditions, cached);
    var items = [];
    for (var i = 0, l = realItems.length; i < l; i++) {
      var realItem = realItems[i];
      items[i] = Item.newInstance(realItem.read());
    }
    return items;
  },

  /**
   * @return {number} length
   */
  length: function Items$length() {
    return this.__private.graph.length();
  },

  /**
   * Change one or more child properties at once
   *
   * @param {{}} newProperties
   * @return {ItemsPrototype}
   */
  changeChildrenPropertiesTo: function Items$changeChildrenPropertiesTo(newProperties) {
    this.__private.graph.changePropertiesTo(newProperties);
    var self = this;
    return {
      saveVersionAs: function() {
        var args = arguments;
        self.saveVersionAs.apply(self, args);
      },
      afterChange: function() {
        var args = arguments;
        self.afterChange.apply(self, args);
      }
    };
  },

  /**
   * Order the graph with the given instructions
   *
   * @param {{}} sortingInstructions
   */
  orderBy: function Items$orderBy(sortingInstructions) {
    this.__private.graph.orderBy(sortingInstructions);
    return this;
  }

};

module.exports = ItemsFactory;
